/**
 * Native C++ client wrapper for MygramDB
 *
 * This module provides a TypeScript wrapper around the native C++ binding,
 * with the same interface as the pure JavaScript client.
 */

import {
  ClientConfig,
  SearchResponse,
  CountResponse,
  Document,
  ServerInfo,
  ReplicationStatus,
  SearchOptions,
  CountOptions,
  DebugInfo
} from './types';
import { ConnectionError, ProtocolError } from './errors';

// Native binding interface
interface NativeBinding {
  createClient(config: { host: string; port: number; timeout: number }): unknown;
  connect(client: unknown): boolean;
  disconnect(client: unknown): void;
  destroyClient(client: unknown): void;
  isConnected(client: unknown): boolean;
  search(client: unknown, table: string, query: string, limit: number, offset: number): string;
  sendCommand(client: unknown, command: string): string;
  getLastError(client: unknown): string;
}

const DEFAULT_CONFIG: Required<ClientConfig> = {
  host: '127.0.0.1',
  port: 11016,
  timeout: 5000,
  recvBufferSize: 65536
};

/**
 * Native MygramDB client using C++ bindings
 *
 * This class provides the same interface as MygramClient but uses
 * native C++ code for better performance.
 */
export class NativeMygramClient {
  private config: Required<ClientConfig>;
  private native: NativeBinding;
  private clientHandle: unknown | null = null;
  private connected = false;

  /**
   * Create a new native MygramDB client
   *
   * @param {NativeBinding} native - Native binding object
   * @param {ClientConfig} [config={}] - Client configuration
   */
  constructor(native: NativeBinding, config: ClientConfig = {}) {
    this.native = native;
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Connect to MygramDB server
   *
   * @returns {Promise<void>} Resolves when connected
   * @throws {ConnectionError} If connection fails
   */
  async connect(): Promise<void> {
    if (this.connected) {
      return Promise.resolve();
    }

    try {
      this.clientHandle = this.native.createClient({
        host: this.config.host,
        port: this.config.port,
        timeout: this.config.timeout
      });

      const result = this.native.connect(this.clientHandle);
      if (!result) {
        const error = this.native.getLastError(this.clientHandle);
        throw new ConnectionError(error || 'Failed to connect');
      }

      this.connected = true;
    } catch (error) {
      if (error instanceof ConnectionError) {
        throw error;
      }
      throw new ConnectionError(error instanceof Error ? error.message : 'Connection failed');
    }
  }

  /**
   * Disconnect from server
   *
   * @returns {void}
   */
  disconnect(): void {
    if (this.clientHandle) {
      this.native.disconnect(this.clientHandle);
      this.native.destroyClient(this.clientHandle);
      this.clientHandle = null;
    }
    this.connected = false;
  }

  /**
   * Check if connected to server
   *
   * @returns {boolean} True if connected, false otherwise
   */
  isConnected(): boolean {
    if (!this.clientHandle) {
      return false;
    }
    return this.native.isConnected(this.clientHandle);
  }

  /**
   * Search for documents in a table
   *
   * @param {string} table - Table name to search in
   * @param {string} query - Search query text
   * @param {SearchOptions} [options={}] - Search options
   * @returns {Promise<SearchResponse>} Search response
   * @throws {ConnectionError} If not connected to server
   * @throws {TimeoutError} If command times out
   * @throws {ProtocolError} If server returns an error
   */
  async search(table: string, query: string, options: SearchOptions = {}): Promise<SearchResponse> {
    const {
      limit = 1000,
      offset = 0,
      andTerms = [],
      notTerms = [],
      filters = {},
      sortColumn = '',
      sortDesc = true
    } = options;

    const parts: string[] = ['SEARCH', table, query];

    // Add AND terms
    if (andTerms.length > 0) {
      andTerms.forEach((term) => {
        parts.push('AND', term);
      });
    }

    // Add NOT terms
    if (notTerms.length > 0) {
      notTerms.forEach((term) => {
        parts.push('NOT', term);
      });
    }

    // Add filters
    const filterEntries = Object.entries(filters);
    if (filterEntries.length > 0) {
      parts.push('FILTER');
      filterEntries.forEach(([key, value], index) => {
        if (index > 0) parts.push('AND');
        parts.push(`${key}=${value}`);
      });
    }

    // Add sort
    if (sortColumn) {
      parts.push('SORT', sortColumn, sortDesc ? 'DESC' : 'ASC');
    }

    // Add limit and offset
    if (offset > 0) {
      parts.push('LIMIT', `${offset},${limit}`);
    } else {
      parts.push('LIMIT', `${limit}`);
    }

    const response = await this.sendCommand(parts.join(' '));
    return this.parseSearchResponse(response);
  }

  /**
   * Count matching documents in a table
   *
   * @param {string} table - Table name
   * @param {string} query - Search query text
   * @param {CountOptions} [options={}] - Count options
   * @returns {Promise<CountResponse>} Count response
   */
  async count(table: string, query: string, options: CountOptions = {}): Promise<CountResponse> {
    const { andTerms = [], notTerms = [], filters = {} } = options;

    const parts: string[] = ['COUNT', table, query];

    if (andTerms.length > 0) {
      andTerms.forEach((term) => {
        parts.push('AND', term);
      });
    }

    if (notTerms.length > 0) {
      notTerms.forEach((term) => {
        parts.push('NOT', term);
      });
    }

    const filterEntries = Object.entries(filters);
    if (filterEntries.length > 0) {
      parts.push('FILTER');
      filterEntries.forEach(([key, value], index) => {
        if (index > 0) parts.push('AND');
        parts.push(`${key}=${value}`);
      });
    }

    const response = await this.sendCommand(parts.join(' '));
    return this.parseCountResponse(response);
  }

  /**
   * Get a document by its primary key
   *
   * @param {string} table - Table name
   * @param {string} primaryKey - Primary key value
   * @returns {Promise<Document>} Document object
   */
  async get(table: string, primaryKey: string): Promise<Document> {
    const response = await this.sendCommand(`GET ${table} ${primaryKey}`);
    return this.parseDocumentResponse(response);
  }

  /**
   * Get server information
   *
   * @returns {Promise<ServerInfo>} Server information
   */
  async info(): Promise<ServerInfo> {
    const response = await this.sendCommand('INFO');
    return this.parseInfoResponse(response);
  }

  /**
   * Get server configuration in YAML format
   *
   * @returns {Promise<string>} Configuration string
   */
  async getConfig(): Promise<string> {
    const response = await this.sendCommand('CONFIG');
    if (!response.startsWith('OK CONFIG')) {
      throw new ProtocolError(`Invalid CONFIG response: ${response}`);
    }
    return response.substring('OK CONFIG\n'.length);
  }

  /**
   * Get replication status
   *
   * @returns {Promise<ReplicationStatus>} Replication status
   */
  async getReplicationStatus(): Promise<ReplicationStatus> {
    const response = await this.sendCommand('REPLICATION STATUS');
    return this.parseReplicationStatusResponse(response);
  }

  /**
   * Stop replication
   *
   * @returns {Promise<void>}
   */
  async stopReplication(): Promise<void> {
    const response = await this.sendCommand('REPLICATION STOP');
    if (!response.startsWith('OK')) {
      throw new ProtocolError(`Failed to stop replication: ${response}`);
    }
  }

  /**
   * Start replication
   *
   * @returns {Promise<void>}
   */
  async startReplication(): Promise<void> {
    const response = await this.sendCommand('REPLICATION START');
    if (!response.startsWith('OK')) {
      throw new ProtocolError(`Failed to start replication: ${response}`);
    }
  }

  /**
   * Enable debug mode
   *
   * @returns {Promise<void>}
   */
  async enableDebug(): Promise<void> {
    const response = await this.sendCommand('DEBUG ON');
    if (!response.startsWith('OK')) {
      throw new ProtocolError(`Failed to enable debug: ${response}`);
    }
  }

  /**
   * Disable debug mode
   *
   * @returns {Promise<void>}
   */
  async disableDebug(): Promise<void> {
    const response = await this.sendCommand('DEBUG OFF');
    if (!response.startsWith('OK')) {
      throw new ProtocolError(`Failed to disable debug: ${response}`);
    }
  }

  /**
   * Send raw command to server
   *
   * @param {string} command - Command string
   * @returns {Promise<string>} Response from server
   * @throws {ConnectionError} If not connected
   */
  async sendCommand(command: string): Promise<string> {
    if (!this.connected || !this.clientHandle) {
      throw new ConnectionError('Not connected to server');
    }

    try {
      const response = this.native.sendCommand(this.clientHandle, command);
      if (response.startsWith('ERROR ')) {
        throw new ProtocolError(response.substring(6));
      }
      return response;
    } catch (error) {
      if (error instanceof ProtocolError) {
        throw error;
      }
      const errorMsg = this.native.getLastError(this.clientHandle);
      throw new ConnectionError(errorMsg || (error instanceof Error ? error.message : 'Command failed'));
    }
  }

  // Response parsing methods (same as MygramClient)
  private parseSearchResponse(response: string): SearchResponse {
    const lines = response.split('\n');
    const firstLine = lines[0];

    if (!firstLine.startsWith('OK RESULTS ')) {
      throw new ProtocolError(`Invalid SEARCH response: ${firstLine}`);
    }

    const parts = firstLine.split(' ');
    const totalCount = parseInt(parts[2], 10);
    const ids = parts.slice(3);

    const results = ids.map((id) => ({ primaryKey: id }));

    let debug: DebugInfo | undefined;
    const debugIndex = lines.findIndex((line) => line === '# DEBUG');
    if (debugIndex !== -1) {
      debug = this.parseDebugInfo(lines.slice(debugIndex + 1));
    }

    return { results, totalCount, debug };
  }

  private parseCountResponse(response: string): CountResponse {
    const lines = response.split('\n');
    const firstLine = lines[0];

    if (!firstLine.startsWith('OK COUNT ')) {
      throw new ProtocolError(`Invalid COUNT response: ${firstLine}`);
    }

    const count = parseInt(firstLine.split(' ')[2], 10);

    let debug: DebugInfo | undefined;
    const debugIndex = lines.findIndex((line) => line === '# DEBUG');
    if (debugIndex !== -1) {
      debug = this.parseDebugInfo(lines.slice(debugIndex + 1));
    }

    return { count, debug };
  }

  private parseDocumentResponse(response: string): Document {
    if (!response.startsWith('OK DOC ')) {
      throw new ProtocolError(`Invalid GET response: ${response}`);
    }

    const parts = response.substring(7).split(' ');
    const primaryKey = parts[0];
    const fields: Record<string, string> = {};

    parts.slice(1).forEach((part) => {
      const [key, value] = part.split('=');
      if (key && value) {
        fields[key] = value;
      }
    });

    return { primaryKey, fields };
  }

  private parseInfoResponse(response: string): ServerInfo {
    if (!response.startsWith('OK INFO')) {
      throw new ProtocolError(`Invalid INFO response: ${response}`);
    }

    const lines = response.split('\n').slice(1);
    const info: Partial<ServerInfo> = {
      version: '',
      uptimeSeconds: 0,
      totalRequests: 0,
      activeConnections: 0,
      indexSizeBytes: 0,
      docCount: 0,
      tables: []
    };

    lines.forEach((line) => {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) return;

      const [key, value] = trimmed.split(':').map((s) => s.trim());
      if (!key || !value) return;

      switch (key) {
        case 'version':
          info.version = value;
          break;
        case 'uptime_seconds':
          info.uptimeSeconds = parseInt(value, 10);
          break;
        case 'total_requests':
          info.totalRequests = parseInt(value, 10);
          break;
        case 'connected_clients':
          info.activeConnections = parseInt(value, 10);
          break;
        case 'used_memory_bytes':
          info.indexSizeBytes = parseInt(value, 10);
          break;
        case 'total_documents':
          info.docCount = parseInt(value, 10);
          break;
        case 'tables':
          info.tables = value.split(',').map((s) => s.trim());
          break;
        default:
          break;
      }
    });

    return info as ServerInfo;
  }

  private parseReplicationStatusResponse(response: string): ReplicationStatus {
    if (!response.startsWith('OK REPLICATION ')) {
      throw new ProtocolError(`Invalid REPLICATION STATUS response: ${response}`);
    }

    const parts = response.substring(15).split(' ');
    const statusPart = parts.find((p) => p.startsWith('status='));
    const gtidPart = parts.find((p) => p.startsWith('gtid='));

    const running = statusPart?.split('=')[1] === 'running';
    const gtid = gtidPart?.split('=')[1] || '';

    return { running, gtid, statusStr: response };
  }

  private parseDebugInfo(lines: string[]): DebugInfo {
    const debug: Partial<DebugInfo> = {
      queryTimeMs: 0,
      indexTimeMs: 0,
      filterTimeMs: 0,
      terms: 0,
      ngrams: 0,
      candidates: 0,
      afterIntersection: 0,
      afterNot: 0,
      afterFilters: 0,
      final: 0,
      optimization: ''
    };

    lines.forEach((line) => {
      const trimmed = line.trim();
      if (!trimmed) return;

      const [key, value] = trimmed.split(':').map((s) => s.trim());
      if (!key || !value) return;

      switch (key) {
        case 'query_time':
          debug.queryTimeMs = parseFloat(value);
          break;
        case 'index_time':
          debug.indexTimeMs = parseFloat(value);
          break;
        case 'filter_time':
          debug.filterTimeMs = parseFloat(value);
          break;
        case 'terms':
          debug.terms = parseInt(value, 10);
          break;
        case 'ngrams':
          debug.ngrams = parseInt(value, 10);
          break;
        case 'candidates':
          debug.candidates = parseInt(value, 10);
          break;
        case 'after_intersection':
          debug.afterIntersection = parseInt(value, 10);
          break;
        case 'after_not':
          debug.afterNot = parseInt(value, 10);
          break;
        case 'after_filters':
          debug.afterFilters = parseInt(value, 10);
          break;
        case 'final':
          debug.final = parseInt(value, 10);
          break;
        case 'optimization':
          debug.optimization = value;
          break;
        case 'order_by':
          debug.orderBy = value;
          break;
        case 'limit':
          debug.limit = parseInt(value.replace('(default)', '').trim(), 10);
          break;
        case 'offset':
          debug.offset = parseInt(value.replace('(default)', '').trim(), 10);
          break;
        default:
          break;
      }
    });

    return debug as DebugInfo;
  }
}
